<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Climate Chord Diagram – Pairwise Correlations</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f9fa;
      text-align: center;
      margin: 20px;
    }
    h1 {
      margin-bottom: 1rem;
    }
    svg {
      margin: auto;
      display: block;
      background: #fff;
      border: 1px solid #ddd;
    }
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <h1>Climate Chord Diagram</h1>
  <svg id="chart" width="700" height="700"></svg>
  <div id="tooltip" class="tooltip"></div>
  
  <script>
    // URL of merged climate CSV
    const CSV_URL = "https://gist.githubusercontent.com/mas5021/546c5cb1aaaaed863bb098b86f71503e/raw/1897725dabe21080a628a0022fa79942c48e1483/merged_climate.csv";
    
    // List of climate variables to analyze.
    const vars = ["SolarIrradiance", "CloudCover", "Precipitation", "Temperature", "VegetationIndex"];
    
    // Set up SVG dimensions.
    const svg = d3.select("#chart"),
          width = +svg.attr("width"),
          height = +svg.attr("height"),
          outerRadius = Math.min(width, height) / 2 - 40,
          innerRadius = outerRadius - 20;
    
    const g = svg.append("g")
                 .attr("transform", `translate(${width/2}, ${height/2})`);
    
    const tooltip = d3.select("#tooltip");
    
    // Helper: Compute Pearson correlation coefficient between two arrays.
    function correlation(x, y) {
      const n = x.length;
      const meanX = d3.mean(x);
      const meanY = d3.mean(y);
      let num = 0, denX = 0, denY = 0;
      for (let i = 0; i < n; i++) {
        const dx = x[i] - meanX;
        const dy = y[i] - meanY;
        num += dx * dy;
        denX += dx * dx;
        denY += dy * dy;
      }
      return num / Math.sqrt(denX * denY);
    }
    
    // Load CSV, parse numeric values and compute a correlation matrix.
    d3.csv(CSV_URL, d => {
      return {
        Year: +d.Year,
        SolarIrradiance: +d.SolarIrradiance,
        CloudCover: +d.CloudCover,
        Precipitation: +d.Precipitation,
        Temperature: +d.Temperature,
        VegetationIndex: +d.VegetationIndex
      };
    }).then(data => {
      // Filter out rows with missing values.
      data = data.filter(d => !isNaN(d.Year) && vars.every(v => !isNaN(d[v])));
      console.log("Data loaded: ", data.length, "rows");
      
      if (data.length === 0) {
        console.error("No valid data rows. Check CSV column names and numeric values.");
        return;
      }
      
      // For each variable, extract an array of its values.
      let valuesByVar = {};
      vars.forEach(v => {
        valuesByVar[v] = data.map(d => d[v]);
      });
      
      // Build a square matrix where entry [i][j] is the absolute correlation between variable i and j.
      const matrix = [];
      for(let i = 0; i < vars.length; i++) {
        matrix[i] = [];
        for(let j = 0; j < vars.length; j++) {
          const corrVal = correlation(valuesByVar[vars[i]], valuesByVar[vars[j]]);
          matrix[i][j] = Math.abs(corrVal); // use absolute correlation for chord widths
        }
      }
      
      console.log("Correlation Matrix:", matrix);
      
      // Create the chord layout using the matrix.
      const chord = d3.chord()
                      .padAngle(0.05)
                      .sortSubgroups(d3.descending)(matrix);
      
      // Define arc generator for outer arcs.
      const arc = d3.arc()
                    .innerRadius(outerRadius)
                    .outerRadius(outerRadius + 20);
      
      // Define ribbon generator for chords.
      const ribbon = d3.ribbon()
                       .radius(innerRadius);
      
      // Draw outer arcs for each variable.
      const group = g.selectAll("g.group")
                     .data(chord.groups)
                     .enter().append("g")
                     .attr("class", "group");
      
      group.append("path")
           .attr("d", arc)
           .attr("fill", (d, i) => d3.schemeCategory10[i % 10])
           .attr("stroke", "#fff")
           .on("mouseover", (event, d) => {
             tooltip.transition().duration(200).style("opacity", 0.9);
             tooltip.html(vars[d.index])
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 20) + "px");
           })
           .on("mouseout", () => {
             tooltip.transition().duration(500).style("opacity", 0);
           });
      
      // Add variable names at the outer edge.
      group.append("text")
           .each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
           .attr("dy", ".35em")
           .attr("transform", d => `
             rotate(${(d.angle * 180 / Math.PI - 90)})
             translate(${outerRadius + 30})
             ${d.angle > Math.PI ? "rotate(180)" : ""}
           `)
           .attr("text-anchor", d => d.angle > Math.PI ? "end" : "start")
           .text((d, i) => vars[i]);
      
      // Draw chords (ribbons) connecting groups.
      g.selectAll("path.chord")
       .data(chord)
       .enter().append("path")
       .attr("class", "chord")
       .attr("d", ribbon)
       .attr("fill", d => d3.schemeCategory10[d.source.index % 10])
       .attr("opacity", 0.7)
       .on("mouseover", (event, d) => {
         tooltip.transition().duration(200).style("opacity", 0.9);
         // Provide details of the connection.
         tooltip.html(`
           <strong>${vars[d.source.index]}</strong> ↔ <strong>${vars[d.target.index]}</strong><br>
           Correlation: ${(matrix[d.source.index][d.target.index]).toFixed(2)}
         `)
         .style("left", (event.pageX + 10) + "px")
         .style("top", (event.pageY - 20) + "px");
       })
       .on("mouseout", () => {
         tooltip.transition().duration(500).style("opacity", 0);
       });
    }).catch(error => {
      console.error("Error loading CSV:", error);
    });
  </script>
</body>
</html>
